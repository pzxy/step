## 深入理解计算机系统(八)异常控制流

为什么要理解异常控制流(Exceptional Control Flow) ECF？

1. 帮助理解系统概念：ECF是用来实现I/O，进程，虚拟内存的基本机制。
2. 帮助理解应用程序如何与操作系统交互：应用程序通过trap陷阱或者系统调用的ECF形式，向操作系统请求服务。比如向磁盘写数据，从网络读数据，创建或终止进程，都需要应用程序调用系统调用来实现。
3. 帮助理解并发，ECF是计算机系统实现并发的基本例子，例子有：中断应用程序执行异常处理程序，在时间上重叠的执行进程和线程。以及中断应用程序执行的信号处理程序。
4. 帮助理解软件异常如何工作，c++和java通过try，catch，throw语句提供软件异常机制。软件异常允许程序进程非本地跳转来响应错误情况。

程序计数器会执行一系列的指令，他有一系列指令的地址。当执行完一个指令以后就会执行下一个，这样过度的过程我们叫做控制转移，这样控制转移的的序列我们叫做控制流，而异常控制流ECF,就是当发生异常的时候去处理异常。

### 1. 异常
当发生虚拟内存缺页，算法溢出，或者除以0的操作，这些称为事件，当处理器检测到这些事件发生时，会通过一张异常表的跳转表，来进行一个间接过程调用，启动异常处理程序。处理完之后有三种可能：
- 控制返回给本指令
- 控制传给下一个指令
- 直接中断
#### 1.1 异常处理
总之就是一句话，先保存异常前的状态，然后处理完之后再恢复状态
 ![cb6720abcb69a06563381df900659ea3.png](en-resource://database/501:1)

#### 1.2 异常表
通过异常表，根据编号执行对应的异常处理程序。
![a65ce79c23b5b20d733f4c82a7d18792.png](en-resource://database/502:1)

#### 1.3 异常分类

![616a665abc2a81307185921cd6dcad96.png](en-resource://database/508:1)

1. 中断，是异步的，来自处理器外部I/O设备(网络适配器，磁盘控制器)信号的结果
![716d8833a15e6cf1aa8dd32d3ea91a40.png](en-resource://database/587:1)

2. 陷阱，系统调用syscall
陷阱是有意的异常。go中syscall包就是做这个的。

![561b16729e5c86589959ae54c5c4b541.png](en-resource://database/503:1)
从程序猿的角度看，系统调用和普通函数一样，但是呢，他们实现非常不同，普通函数运行在用户模式中，用户模式限制了函数的指令类型，只允许访问与调用函数相同的栈，系统调用运行在内核中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈.

![c8aee4d566f860fd7866e822d5b13328.png](en-resource://database/504:1)
3. 故障
由错误引起，可能被故障处理程序修正。
举例：缺页异常，当指令引用一个虚拟地址，与该地址相对应的物理页面不在内存中，因此必须从磁盘取出就会发生故障。

![172b08fa69924f3aa335a00cede7ad47.png](en-resource://database/588:1)

4. 终止

不可恢复的致命结果，dram sram位辈损坏时发生奇偶错误。![110afa1008000585c638ace02f79b3f9.png](en-resource://database/589:1)

示例：`x86-64异常示例：`
![601901ca8b438b0b2a56dd38ed1bcb09.png](en-resource://database/590:1)

### 2. 进程
进程就是，执行中程序的实例
![2046c4bd91960a2a20a0f21cb972a790.png](en-resource://database/506:1)
进程给应用程序的抽象
- 一个独立的逻辑控制流，它提供一种假象，好像我们的程序独占的使用处理器。
- 一个私有的地址空间，它提供一种假象，好像一个程序独占的使用内存系统。
1. 逻辑控制流
![b1c4ba0d4f9d5d10c7be6edcbbc6322b.png](en-resource://database/505:1)


2. 并发流
 一个逻辑流执行在执行时间上与另外一个流重叠，称为并发流(concurrent flow)
 并发流的思想与处理器核数，或者计算数无关，如果两个流在时间上是重叠的，那么他们就是并发的，即使他们运行在同一个处理器上。
 

3. 私有地址空间
进程为每个程序提供它自己的私有地址空间。
地址空间是2的n次方大小，但是不一定是连续的地址。
每个这样的地址空间都有相同的通用结构。
好好看这个图
![2ca3e90f2ad2be52dd1eda020071aaed.png](en-resource://database/591:1)
代码，数据，堆，栈等。
0～0x00400000 保留给内核，操作系统常驻内存部分。

4. 用户模式和内核模式
设置了控制寄存器一个模拟位(modebit)后，该寄存器描述了进程当前现有的特权，进程就会运行在内核模式中。
内核模式的进程可以执行指令集中的任何指令，访问系统中的任何内存位置。
没设置模拟位时，进程就运行在用户模式中，用户模式时可以访问内核代码和数据，但是必须通过系统接口调用间接的访问内核代码和数据。

用户模式->内核模式
- 中断
- 故障
- 陷阱，陷入系统调用这样的异常。

Linux中访问内核数据
通过/proc文件系统，/sys文件系统。访问一些内核中的系统属性。比如cpu类型等。

5. 进程上下文切换
方式：抢占式
形式：sleep，中断都会引起上下文切换
![ff80ee7739c14091c613073e9f46c85f.png](en-resource://database/507:1)


6. 关于并发和并行
并发就是会在相同时间段执行，和处理器的个数没有关系。
并行就是运行在不同的机器或者处理器上执行。并行是并发的子集。


### 3. 系统调用错误处理
我觉得这种写法需要好好学习

一个a()函数可能会出错，我们用一个A()函数将a()包一个，在A()中进行错误处理。
```go
package main

import (
	"errors"
	"os"
)

/**
很好的错误处理的写法。
 */
func main() {
	A()
}

func a() int {
	return -1
}

func A() int {
	r := a()
	if r < 0 {
		a_err("print err info ")
	}
	return r
}

func a_err(s string) {
	errors.New(s)
	os.Exit(0) //平时的话，是不是要用return呢？
	//在平时写代码的过程中，是不是要加上什么也不做的处理呢。这样的话，有错的话，我就返回缺省值，
	// 缺省值就是什么也不做，这样在A()外面我也不用再次判断返回值。直接就可以运行了。相当于什么也不错。
	//我觉得这样写很好。
}

```


### 4. 进程控制
1. 获取进程
getpid获取进程id
getppid获取父进程id
2. 创建和终止进程

状态：
- 运行
- 停止，被挂起，收到sigstop，sigtstp，sigttin，sigtout。
- 终止

fork函数创建子进程：
调用一次，返回两次，父进程返回子进程id，子进程各返回0。
父子进程特点：
- 子进程有父进程虚拟内存空间、已打开的文件描述符的副本。
- 并发执行
- 相同但有独立的地址空间
- 共享文件

3. 回收子进程
>进程终止后并不是立马被回收，而是保持终止状态，等待被回收。

- 僵死进程zombie
一个进程终止了，没有被回收的进程。
- 孤儿进程
父进程终止的进程子进程。
孤儿进程还好，init进程会接管终止的父进程的子进程，从而回收他。

4. 进程休眠
sleep
5. 加载并运行程序

execve函数：
在当前进程的上下文中加载并运行一个新的程序，他会覆盖当前进程的地址空间，但并没有创建一个新的进程，新的程序仍然有新的pid。
### 5. 信号
>一个信号就是一条小消息，他通知进程系统中发生了一个某种类型的事件。
linux信号：
![b6a7e431a0d28503ca1cba38b487263b.png](en-resource://database/510:1)
1. 信号术语
- 发送信号
1)内核检查到一个系统事件，比如除0错误，子进程终止。
2)一个进程调用了kill函数，显示的要求内核发送一个信号给目的地。一个进程可以将信号发给自己。

- 接收信号

![b7218b2e2e49e7085da044f114f4aeb5.png](en-resource://database/592:1)

2. 发送信号

进程组：
向进程发送信号的机制时基于进程组的。
- 子进程和父进程同属一个进程组，进程组gid时父进程id。
- 一个进程可以使用setpgid改变自己或者其他进程的进程组。

 用/bin/kill程序发送信号：
 /bin/kill程序可以向另外的进程发送任意信号
```bash
/bin/kill -9 123123
#发送信号9(SIGKIll)给进程123123，一个为负的PID，会导致信号被发送到进程组PID中的每个进程。
```
 从键盘发送信号：
Ctrl+c
![7a018c9bf5ee2d706b99038a8279283e.png](en-resource://database/593:1)
用Kill函数发送信号：
可以发送信号给自己或者其他进程
```c
int kill(pid_id pid,int sig)
```

用alarm函数发送信号：
给自己发送SIGALRM信号

3. 接收信号
- 除了sigstopsigkill信号，其他信号都能被修改
- 主程序可以改被信号处理程序中断，信号处理程序还能被别的信号处理程序中断
![5373ec984f245d2a8edd78716d3ebc9f.png](en-resource://database/594:1)

4. 阻塞和解除阻塞信号
相同类型的信号，只能处理一个。

5. 编写信号处理程序(csapp8.5.5)
- 安全的信号处理程序
- 正确的信号处理
就是说相同的信号只会有两个存在，一个被处理，一个在等待，这个时候还有第三个相同信号发到相同的目的地，那么只能丢弃

### 6. 非本地跳转(nonlocal jump)
>将控制直接从一个函数转移到另外一个正在执行的函数，而不需要正常的调用返回序列。

相关函数：
setjmp，保存函数的调用环境(程序计数器、栈指针、通用目寄存器)
longjmp，回复调用环境，返回最近的一次setjmp返回。

应用：
最重要的应用就是，从一个深层嵌套的函数调用中立即返回。
比如发生了一个错误，我们可以立即返回到一个普通的本地化的错误处理程序，而不是费力的解开调用栈。

java中的try、catch相当于setjmp，throw相当于longjmp。

### 7. 操作系统的工具
Linux中提供了大量操作系统的工具
- STARCE：打印一个正在运行的程序，和他的子进程调用的每个系统的调用的轨迹。(用`-static`编译你的程序，输出的轨迹更干净，不带有大量的共享库)
- PS 列出当前系统中的进程(包括僵死进程)
- TOP 打印出关于当前进程资源使用的信息。
- PMAP 显示进程的内存映射
/proc：一个虚拟文件系统，一ASCII文本格式输出大量内核数据的内容。比如：
```bash
cat/proc/loadavg
#看到linux系统上的平均负载
```
### 总结
![5c638b2bb48a6f0f81b707e4b2cadfd1.png](en-resource://database/595:1)

#### 单词
1. control transfer 控制转移
2. control flow 控制流
3. Exceptional Control Flow ，ECF 异常控制流
4. exception 异常
5. exception table 异常表
6. exception handler 异常处理程序
7. exception table base register ，异常表基址寄存器
8. interrupt 中断
9. trap 陷阱
10. fault 故障
11. abort 终止
12. preempted 抢占，暂时挂起[pri'empt, ,pri:-]
13. concurrent flow 并发流
14. concurrency并发
15. multitasking 多任务
16. time slice  时间片
17. time slicing 时间分片
18. parallel flow 并行流
19. running in parallel 并行的运行
20. parallel execution  并行的执行
21. mode bit  模拟位
22. ‘privileged instruction 特权指令[ˈprɪvəlɪdʒd]
23. context switch上下文切换
24. scheduler 调度
25. suspended 刮挂起
26. reaped回收
27. 僵尸进程 aombie
28. 等待集合 wait set
29. lopological sort 拓扑排序
30. pending signal 待处理信号
31. process group 进程组
32. alarm 闹钟
33. dumping core转储内存（其实是写入磁盘
34. 不稳定的 volatile ）
35. race 竞争
36. nonlocal jump 非本地跳转
